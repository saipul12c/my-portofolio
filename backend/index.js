const express = require('express');
const path = require('path');
const cors = require('cors');
const dotenv = require('dotenv');
const fs = require('fs').promises;
const { existsSync } = require('fs');
const http = require('http');
const { v4: uuidv4 } = require('uuid');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { Server } = require('socket.io');

dotenv.config();

const PORT = process.env.PORT || 8080;
const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: process.env.ALLOWED_ORIGINS ? process.env.ALLOWED_ORIGINS.split(',') : '*' } });

// CORS
const allowed = process.env.ALLOWED_ORIGINS ? process.env.ALLOWED_ORIGINS.split(',') : ['*'];
app.use(cors({ origin: allowed }));

app.use(express.json());

// Serve frontend public/data as backend-static so frontend can fetch via backend
const FRONTEND_PUBLIC_DATA = path.join(__dirname, '..', 'public', 'data');
if (existsSync(FRONTEND_PUBLIC_DATA)) {
  app.use('/data', express.static(FRONTEND_PUBLIC_DATA));
}

// Serve simple avatar static assets located under backend/public/avatar
const BACKEND_AVATAR_DIR = path.join(__dirname, 'public', 'avatar');
if (existsSync(BACKEND_AVATAR_DIR)) {
  app.use('/avatar', express.static(BACKEND_AVATAR_DIR));
}

// Generic endpoint to serve static JSON or other files from frontend folders
app.get('/api/static/*', async (req, res) => {
  const rel = req.params[0] || '';
  // Candidate locations (public/data first, then src/data)
  const candidates = [
    path.join(__dirname, '..', 'public', 'data', rel),
    path.join(__dirname, '..', 'src', 'data', rel)
  ];

  for (const p of candidates) {
    try {
      if (existsSync(p)) {
        // If it's a directory, reject
        const stat = await fs.stat(p);
        if (stat.isDirectory()) continue;
        const txt = await fs.readFile(p, 'utf8');
        if (p.toLowerCase().endsWith('.json')) {
          try {
            return res.json(JSON.parse(txt || 'null'));
          } catch (err) {
            return res.status(500).json({ error: 'Invalid JSON file' });
          }
        }
        // fallback: send raw content with content-type by extension
        const ext = path.extname(p).slice(1) || 'txt';
        res.type(ext).send(txt);
        return;
      }
    } catch (err) {
      // continue to next candidate
    }
  }

  res.status(404).json({ error: 'Static file not found' });
});

// Data directory inside backend
const DB_DIR = path.join(__dirname, 'data');
const DATA_FILES = {
  users: path.join(DB_DIR, 'users.json'),
  communities: path.join(DB_DIR, 'communities.json'),
  channels: path.join(DB_DIR, 'channels.json'),
  messages: path.join(DB_DIR, 'messages.json')
};

// additional data stores we can safely add without changing existing behavior
DATA_FILES.bots = path.join(DB_DIR, 'bots.json');
DATA_FILES.account_tiers = path.join(DB_DIR, 'account_tiers.json');
// Expanded autogenerated stores for bulk/experimental endpoints
DATA_FILES.expanded_community = path.join(DB_DIR, 'expanded_community.json');
DATA_FILES.expanded_streaming = path.join(DB_DIR, 'expanded_streaming.json');
// Discord related stores
DATA_FILES.discord_servers = path.join(DB_DIR, 'discord_servers.json');
DATA_FILES.discord_invites = path.join(DB_DIR, 'discord_invites.json');
DATA_FILES.discord_roles = path.join(DB_DIR, 'discord_roles.json');
DATA_FILES.discord_webhooks = path.join(DB_DIR, 'discord_webhooks.json');
DATA_FILES.discord_presence = path.join(DB_DIR, 'discord_presence.json');

// YouTube related stores
DATA_FILES.youtube_channels = path.join(DB_DIR, 'youtube_channels.json');
DATA_FILES.youtube_videos = path.join(DB_DIR, 'youtube_videos.json');
DATA_FILES.youtube_comments = path.join(DB_DIR, 'youtube_comments.json');
DATA_FILES.youtube_playlists = path.join(DB_DIR, 'youtube_playlists.json');
DATA_FILES.youtube_live_streams = path.join(DB_DIR, 'youtube_live_streams.json');
DATA_FILES.youtube_analytics = path.join(DB_DIR, 'youtube_analytics.json');

const MESSAGES_DIR = path.join(DB_DIR, 'messages');
const USERS_DIR = path.join(DB_DIR, 'users');

async function ensureDataFiles() {
  if (!existsSync(DB_DIR)) {
    await fs.mkdir(DB_DIR, { recursive: true });
  }
  if (!existsSync(USERS_DIR)) {
    await fs.mkdir(USERS_DIR, { recursive: true });
  }
  if (!existsSync(MESSAGES_DIR)) {
    await fs.mkdir(MESSAGES_DIR, { recursive: true });
  }
  for (const key of Object.keys(DATA_FILES)) {
    const p = DATA_FILES[key];
    if (!existsSync(p)) {
      await fs.writeFile(p, '[]', 'utf8');
    }
  }

  // lightweight migration: if global messages.json has items, create per-channel files
  try {
    const globalMsgs = await readJSON(DATA_FILES.messages);
    if (globalMsgs && globalMsgs.length > 0) {
      const byChannel = new Map();
      globalMsgs.forEach(m => {
        const cid = String(m.channel_id || 'unknown');
        if (!byChannel.has(cid)) byChannel.set(cid, []);
        byChannel.get(cid).push(m);
      });
      for (const [cid, msgs] of byChannel.entries()) {
        const p = path.join(MESSAGES_DIR, `${cid}.json`);
        if (!existsSync(p)) {
          await fs.writeFile(p, JSON.stringify(msgs, null, 2), 'utf8');
        }
      }
    }
  } catch (err) {
    // non-fatal
    console.warn('Migration to per-channel message files failed:', err.message || err);
  }
}

async function readJSON(file) {
  try {
    const txt = await fs.readFile(file, 'utf8');
    return JSON.parse(txt || '[]');
  } catch (err) {
    return [];
  }
}

async function readChannelMessagesFile(channelId) {
  const p = path.join(MESSAGES_DIR, `${channelId}.json`);
  try {
    if (!existsSync(p)) return [];
    const txt = await fs.readFile(p, 'utf8');
    return JSON.parse(txt || '[]');
  } catch (err) {
    return [];
  }
}

async function getProfileForUser(userId) {
  if (!userId) return null;
  try {
    // per-user profile file (public profile) takes precedence
    const userFile = path.join(USERS_DIR, `${userId}.json`);
    if (existsSync(userFile)) {
      const txt = await fs.readFile(userFile, 'utf8');
      return JSON.parse(txt || '{}');
    }

    // fallback: search in central users list
    const users = await readJSON(DATA_FILES.users);
    const u = users.find(x => String(x.id) === String(userId));
    if (u) return { id: u.id, username: u.username, avatar_url: u.avatar_url };
    return null;
  } catch (err) {
    return null;
  }
}

async function writeChannelMessagesFile(channelId, data) {
  const p = path.join(MESSAGES_DIR, `${channelId}.json`);
  await fs.writeFile(p, JSON.stringify(data, null, 2), 'utf8');
}

async function writeJSON(file, data) {
  await fs.writeFile(file, JSON.stringify(data, null, 2), 'utf8');
}

const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret';

// Health
app.get('/health', (req, res) => res.json({ status: 'ok' }));

// Backwards-compatible alias used by frontend helpers (some places call /api/health)
app.get('/api/health', (req, res) => res.json({ status: 'ok' }));

// --- AUTH ---
app.post('/api/auth/signup', async (req, res) => {
  const { email, password, username } = req.body;
  if (!email || !password) return res.status(400).json({ error: 'email and password required' });

  await ensureDataFiles();
  const users = await readJSON(DATA_FILES.users);
  // Ensure unique email and username
  if (users.find(u => u.email === email)) return res.status(409).json({ error: 'Email already registered' });
  if (username && users.find(u => (u.username || '').toLowerCase() === String(username).toLowerCase())) return res.status(409).json({ error: 'Username already taken' });

  const hashed = await bcrypt.hash(password, 10);
  const newUser = {
    id: uuidv4(),
    email,
    username: username || email.split('@')[0],
    password_hash: hashed,
    role: 'user',
    created_at: new Date().toISOString()
  };

  // add to central users list
  users.push(newUser);
  await writeJSON(DATA_FILES.users, users);

  // create per-user profile file (public profile only)
  const profile = {
    id: newUser.id,
    email: newUser.email,
    username: newUser.username,
    role: newUser.role,
    created_at: newUser.created_at
  };
  const userFile = path.join(USERS_DIR, `${newUser.id}.json`);
  await fs.writeFile(userFile, JSON.stringify(profile, null, 2), 'utf8');

  const token = jwt.sign({ sub: newUser.id }, JWT_SECRET, { expiresIn: '7d' });
  res.status(201).json({ user: { id: newUser.id, email: newUser.email, username: newUser.username }, token });
});

app.post('/api/auth/signin', async (req, res) => {
  const { email, password } = req.body;
  if (!email || !password) return res.status(400).json({ error: 'email and password required' });

  await ensureDataFiles();
  const users = await readJSON(DATA_FILES.users);
  const user = users.find(u => u.email === email);
  if (!user) return res.status(401).json({ error: 'Invalid credentials' });

  const ok = await bcrypt.compare(password, user.password_hash || '');
  if (!ok) return res.status(401).json({ error: 'Invalid credentials' });

  const token = jwt.sign({ sub: user.id }, JWT_SECRET, { expiresIn: '7d' });
  res.json({ user: { id: user.id, email: user.email, username: user.username }, token });
});

function getUserFromAuthHeader(req) {
  const h = req.headers.authorization;
  if (!h) return null;
  const parts = h.split(' ');
  if (parts.length !== 2) return null;
  const token = parts[1];
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    return payload.sub;
  } catch (err) {
    return null;
  }
}

app.get('/api/auth/me', async (req, res) => {
  await ensureDataFiles();
  const userId = getUserFromAuthHeader(req);
  if (!userId) return res.status(401).json({ error: 'Not authenticated' });
  const users = await readJSON(DATA_FILES.users);
  const user = users.find(u => u.id === userId);
  if (!user) return res.status(404).json({ error: 'User not found' });
  res.json({ id: user.id, email: user.email, username: user.username, role: user.role });
});

// Update profile
app.put('/api/profiles/:id', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  const updates = req.body;
  const users = await readJSON(DATA_FILES.users);
  const idx = users.findIndex(u => String(u.id) === String(id));
  if (idx === -1) return res.status(404).json({ error: 'User not found' });
  // prevent password overwrite via this endpoint
  delete updates.password;
  delete updates.password_hash;
  users[idx] = { ...users[idx], ...updates, updated_at: new Date().toISOString() };
  await writeJSON(DATA_FILES.users, users);
  const user = users[idx];
  res.json({ id: user.id, email: user.email, username: user.username, role: user.role, avatar_url: user.avatar_url });
});

// --- COMMUNITIES ---
app.get('/api/communities', async (req, res) => {
  await ensureDataFiles();
  const data = await readJSON(DATA_FILES.communities);
  // newest first
  data.sort((a,b) => new Date(b.created_at) - new Date(a.created_at));
  res.json(data);
});

app.get('/api/communities/:id', async (req, res) => {
  await ensureDataFiles();
  const data = await readJSON(DATA_FILES.communities);
  const item = data.find(d => String(d.id) === String(req.params.id));
  if (!item) return res.status(404).json({ error: 'Not found' });
  res.json(item);
});

app.post('/api/communities', async (req, res) => {
  await ensureDataFiles();
  const payload = req.body;
  const data = await readJSON(DATA_FILES.communities);
  const newItem = { id: uuidv4(), ...payload, created_at: new Date().toISOString() };
  data.push(newItem);
  await writeJSON(DATA_FILES.communities, data);
  res.status(201).json(newItem);
});

app.put('/api/communities/:id', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  const payload = req.body;
  const data = await readJSON(DATA_FILES.communities);
  const idx = data.findIndex(d => String(d.id) === String(id));
  if (idx === -1) return res.status(404).json({ error: 'Not found' });
  data[idx] = { ...data[idx], ...payload, updated_at: new Date().toISOString() };
  await writeJSON(DATA_FILES.communities, data);
  res.json(data[idx]);
});

app.delete('/api/communities/:id', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  let data = await readJSON(DATA_FILES.communities);
  const idx = data.findIndex(d => String(d.id) === String(id));
  if (idx === -1) return res.status(404).json({ error: 'Not found' });
  const removed = data.splice(idx,1);
  await writeJSON(DATA_FILES.communities, data);
  res.json({ deleted: removed[0] });
});

// --- SERVERS / CHANNELS ---
app.get('/api/servers', async (req, res) => {
  await ensureDataFiles();
  // servers are derived from channels' server_id or stored separately; create simple servers list
  const channels = await readJSON(DATA_FILES.channels);
  const serverMap = new Map();
  channels.forEach(c => {
    if (!serverMap.has(c.server_id)) {
      serverMap.set(c.server_id, { id: c.server_id, name: c.server_name || 'Server', icon: 'ðŸŸ¢', created_at: c.created_at });
    }
  });
  res.json(Array.from(serverMap.values()));
});

app.get('/api/channels', async (req, res) => {
  await ensureDataFiles();
  const serverId = req.query.server_id;
  let channels = await readJSON(DATA_FILES.channels);
  if (serverId) channels = channels.filter(c => String(c.server_id) === String(serverId));
  channels.sort((a,b) => (a.position || 0) - (b.position || 0));
  res.json(channels);
});

app.post('/api/channels', async (req, res) => {
  await ensureDataFiles();
  const payload = req.body; // should include server_id, name, position
  const channels = await readJSON(DATA_FILES.channels);
  const serverChannels = channels.filter(c => String(c.server_id) === String(payload.server_id));
  if (serverChannels.length >= 50) return res.status(400).json({ error: 'Max 50 channels per server' });
  const newCh = { id: uuidv4(), ...payload, created_at: new Date().toISOString() };
  channels.push(newCh);
  await writeJSON(DATA_FILES.channels, channels);
  res.status(201).json(newCh);
});

// --- MESSAGES: persisted + realtime via socket.io ---
app.get('/api/messages', async (req, res) => {
  await ensureDataFiles();
  const channelId = req.query.channel_id;
  // If per-channel file exists, read that to avoid scanning large global file.
  if (channelId) {
    let messages = await readChannelMessagesFile(channelId);
    messages.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
    const enriched = await Promise.all(messages.slice(-200).map(async (m) => ({
      ...m,
      profiles: await getProfileForUser(m.user_id)
    })));
    return res.json(enriched);
  }

  // fallback: return last 200 from global messages file
  let messages = await readJSON(DATA_FILES.messages);
  messages.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
  const last = messages.slice(-200);
  const enriched = await Promise.all(last.map(async (m) => ({ ...m, profiles: await getProfileForUser(m.user_id) })));
  res.json(enriched);
});

app.post('/api/messages', async (req, res) => {
  await ensureDataFiles();
  const { channel_id, user_id, content } = req.body;
  if (!channel_id || !user_id || !content) return res.status(400).json({ error: 'channel_id, user_id, content required' });
  const messages = await readJSON(DATA_FILES.messages);
  const newMessage = { id: uuidv4(), channel_id, user_id, content, created_at: new Date().toISOString() };
  messages.push(newMessage);
  await writeJSON(DATA_FILES.messages, messages);

  // also write to per-channel file to keep files smaller and easier to manage
  try {
    const chMsgs = await readChannelMessagesFile(channel_id);
    chMsgs.push(newMessage);
    await writeChannelMessagesFile(channel_id, chMsgs);
  } catch (err) {
    console.warn('Failed to write per-channel messages file', err.message || err);
  }
  // prepare enriched object with author profile
  try {
    const profile = await getProfileForUser(user_id);
    const outgoing = { ...newMessage, profiles: profile };
    // broadcast via socket.io
    io.to(String(channel_id)).emit('message', outgoing);
    res.status(201).json(outgoing);
  } catch (err) {
    // best-effort: still return minimally enriched payload
    io.to(String(channel_id)).emit('message', newMessage);
    res.status(201).json({ ...newMessage, profiles: null });
  }
});

// --- STREAMING / VIDEO DATA (serve frontend static JSON under src/pages/streming/data) ---
const STREAMING_DATA_DIR = path.join(__dirname, '..', 'src', 'pages', 'streming', 'data');

async function tryReadStreamingFile(name) {
  const p1 = path.join(STREAMING_DATA_DIR, name);
  const p2 = path.join(__dirname, '..', 'public', 'data', 'streming', name);
  if (existsSync(p1)) return await readJSON(p1);
  if (existsSync(p2)) return await readJSON(p2);
  return [];
}

app.get('/api/videos', async (req, res) => {
  try {
    const q = String(req.query.q || '').trim().toLowerCase();
    const videos = await tryReadStreamingFile('videosData.json');
    if (q) {
      const filtered = videos.filter(v => (v.title || '').toLowerCase().includes(q) || (v.description || '').toLowerCase().includes(q) || (v.channel || '').toLowerCase().includes(q));
      return res.json(filtered);
    }
    res.json(videos);
  } catch (err) {
    res.status(500).json({ error: 'Failed to read videos data' });
  }
});

app.get('/api/shorts', async (req, res) => {
  try {
    const shorts = await tryReadStreamingFile('shortsData.json');
    res.json(shorts);
  } catch (err) {
    res.status(500).json({ error: 'Failed to read shorts data' });
  }
});

app.get('/api/streaming-users', async (req, res) => {
  try {
    const users = await tryReadStreamingFile('userData.json');
    // if the file is a single object rather than array, return it as object
    return res.json(users);
  } catch (err) {
    res.status(500).json({ error: 'Failed to read streaming user data' });
  }
});

// Endpoint: top active channels by distinct users (default limit 10)
app.get('/api/channels/active', async (req, res) => {
  await ensureDataFiles();
  const limit = Math.max(1, Math.min(100, parseInt(req.query.limit || '10', 10)));
  const channels = await readJSON(DATA_FILES.channels);

  // For each channel, try to read per-channel messages file first, fallback to scanning global messages
  const results = await Promise.all(channels.map(async (ch) => {
    let chMsgs = await readChannelMessagesFile(ch.id);
    if (!chMsgs || chMsgs.length === 0) {
      // fallback: scan global messages once
      const allMsgs = await readJSON(DATA_FILES.messages);
      chMsgs = allMsgs.filter(m => String(m.channel_id) === String(ch.id));
    }
    const message_count = chMsgs.length;
    const unique_users = new Set(chMsgs.filter(m => m.user_id).map(m => String(m.user_id)));
    return {
      ...ch,
      message_count,
      member_count: unique_users.size
    };
  }));

  // sort by member_count desc, then message_count desc
  results.sort((a,b) => (b.member_count - a.member_count) || (b.message_count - a.message_count));
  res.json(results.slice(0, limit));
});

// Socket.IO handlers
io.on('connection', (socket) => {
  socket.on('join', (payload) => {
    // payload: { channelId, user }
    if (!payload || !payload.channelId) return;
    socket.join(String(payload.channelId));
    socket.emit('joined', { channelId: payload.channelId });
  });

  socket.on('leave', (payload) => {
    if (!payload || !payload.channelId) return;
    socket.leave(String(payload.channelId));
  });

  socket.on('message', async (payload) => {
    // payload: { channelId, userId, content }
    try {
      if (!payload || !payload.channelId || !payload.content) return;
      await ensureDataFiles();
      const messages = await readJSON(DATA_FILES.messages);
      const newMessage = { id: uuidv4(), channel_id: payload.channelId, user_id: payload.userId || null, content: payload.content, created_at: new Date().toISOString() };
      messages.push(newMessage);
      await writeJSON(DATA_FILES.messages, messages);
      // attach profile info before broadcasting
      const profile = await getProfileForUser(payload.userId || null);
      io.to(String(payload.channelId)).emit('message', { ...newMessage, profiles: profile });
    } catch (err) {
      console.error('Socket message error', err);
    }
  });
});


// --- ADDITIONAL API ENDPOINTS (non-destructive additions) ---
// These endpoints extend functionality but keep existing routes intact.

// List all users (sanitized)
app.get('/api/users', async (req, res) => {
  await ensureDataFiles();
  const users = await readJSON(DATA_FILES.users);
  const q = String(req.query.q || '').toLowerCase().trim();
  let out = users.map(u => ({ id: u.id, username: u.username, email: u.email, avatar_url: u.avatar_url, role: u.role }));
  if (q) out = out.filter(u => (u.username || '').toLowerCase().includes(q) || (u.email || '').toLowerCase().includes(q));
  res.json(out);
});

// Get public profile for a user
app.get('/api/users/:id', async (req, res) => {
  await ensureDataFiles();
  const profile = await getProfileForUser(req.params.id);
  if (!profile) return res.status(404).json({ error: 'User not found' });
  res.json(profile);
});

// Update user avatar (accepts JSON { avatar_url })
app.post('/api/users/:id/avatar', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  const { avatar_url } = req.body || {};
  if (!avatar_url) return res.status(400).json({ error: 'avatar_url required' });
  // update per-user profile file if exists, otherwise update central list
  const userFile = path.join(USERS_DIR, `${id}.json`);
  try {
    if (existsSync(userFile)) {
      const txt = await fs.readFile(userFile, 'utf8');
      const obj = JSON.parse(txt || '{}');
      obj.avatar_url = avatar_url;
      obj.updated_at = new Date().toISOString();
      await fs.writeFile(userFile, JSON.stringify(obj, null, 2), 'utf8');
    }
    const users = await readJSON(DATA_FILES.users);
    const idx = users.findIndex(u => String(u.id) === String(id));
    if (idx !== -1) {
      users[idx].avatar_url = avatar_url;
      users[idx].updated_at = new Date().toISOString();
      await writeJSON(DATA_FILES.users, users);
    }
    res.json({ id, avatar_url });
  } catch (err) {
    res.status(500).json({ error: 'Failed to update avatar' });
  }
});

// Get messages for a user (across channels, last 200)
app.get('/api/users/:id/messages', async (req, res) => {
  await ensureDataFiles();
  const uid = req.params.id;
  const allMsgs = await readJSON(DATA_FILES.messages);
  const filtered = allMsgs.filter(m => String(m.user_id) === String(uid));
  filtered.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
  res.json(filtered.slice(-200));
});

// Edit a message (simple text update)
app.patch('/api/messages/:id', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  const { content } = req.body || {};
  if (typeof content !== 'string') return res.status(400).json({ error: 'content required' });
  let messages = await readJSON(DATA_FILES.messages);
  const idx = messages.findIndex(m => String(m.id) === String(id));
  if (idx === -1) return res.status(404).json({ error: 'Message not found' });
  messages[idx].content = content;
  messages[idx].edited_at = new Date().toISOString();
  await writeJSON(DATA_FILES.messages, messages);
  // update per-channel file if present
  const channelId = messages[idx].channel_id;
  try {
    const chMsgs = await readChannelMessagesFile(channelId);
    const cidx = chMsgs.findIndex(m => String(m.id) === String(id));
    if (cidx !== -1) {
      chMsgs[cidx].content = content;
      chMsgs[cidx].edited_at = messages[idx].edited_at;
      await writeChannelMessagesFile(channelId, chMsgs);
    }
  } catch (err) {
    // non-fatal
  }
  res.json(messages[idx]);
});

// Delete a message by id
app.delete('/api/messages/:id', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  let messages = await readJSON(DATA_FILES.messages);
  const idx = messages.findIndex(m => String(m.id) === String(id));
  if (idx === -1) return res.status(404).json({ error: 'Message not found' });
  const removed = messages.splice(idx, 1)[0];
  await writeJSON(DATA_FILES.messages, messages);
  // remove from per-channel file if present
  try {
    const chMsgs = await readChannelMessagesFile(removed.channel_id);
    const cidx = chMsgs.findIndex(m => String(m.id) === String(id));
    if (cidx !== -1) {
      chMsgs.splice(cidx, 1);
      await writeChannelMessagesFile(removed.channel_id, chMsgs);
    }
  } catch (err) {
    // ignore
  }
  res.json({ deleted: removed });
});

// Simple global search across communities, channels, users
app.get('/api/search', async (req, res) => {
  await ensureDataFiles();
  const q = String(req.query.q || '').toLowerCase().trim();
  if (!q) return res.status(400).json({ error: 'q query parameter required' });
  const [communities, channels, users] = await Promise.all([
    readJSON(DATA_FILES.communities),
    readJSON(DATA_FILES.channels),
    readJSON(DATA_FILES.users)
  ]);
  const cRes = communities.filter(c => (c.name || '').toLowerCase().includes(q) || (c.description || '').toLowerCase().includes(q)).slice(0,20);
  const chRes = channels.filter(c => (c.name || '').toLowerCase().includes(q)).slice(0,20);
  const uRes = users.filter(u => (u.username || '').toLowerCase().includes(q) || (u.email || '').toLowerCase().includes(q)).slice(0,20).map(u => ({ id: u.id, username: u.username, avatar_url: u.avatar_url }));
  res.json({ communities: cRes, channels: chRes, users: uRes });
});

// Channel summary: counts, last message, active users
app.get('/api/channels/:id/summary', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  const channels = await readJSON(DATA_FILES.channels);
  const ch = channels.find(c => String(c.id) === String(id));
  if (!ch) return res.status(404).json({ error: 'Channel not found' });
  let chMsgs = await readChannelMessagesFile(id);
  if (!chMsgs || chMsgs.length === 0) {
    const allMsgs = await readJSON(DATA_FILES.messages);
    chMsgs = allMsgs.filter(m => String(m.channel_id) === String(id));
  }
  chMsgs.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
  const last = chMsgs.length ? chMsgs[chMsgs.length - 1] : null;
  const uniqueUsers = new Set(chMsgs.filter(m => m.user_id).map(m => String(m.user_id)));
  res.json({ channel: ch, message_count: chMsgs.length, member_count: uniqueUsers.size, last_message: last });
});

// Rename a channel (lightweight helper route)
app.post('/api/channels/:id/rename', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  const { name } = req.body || {};
  if (!name) return res.status(400).json({ error: 'name required' });
  const channels = await readJSON(DATA_FILES.channels);
  const idx = channels.findIndex(c => String(c.id) === String(id));
  if (idx === -1) return res.status(404).json({ error: 'Channel not found' });
  channels[idx].name = name;
  channels[idx].updated_at = new Date().toISOString();
  await writeJSON(DATA_FILES.channels, channels);
  res.json(channels[idx]);
});

// Manage community members: add member
app.post('/api/communities/:id/members', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  const { user_id } = req.body || {};
  if (!user_id) return res.status(400).json({ error: 'user_id required' });
  const data = await readJSON(DATA_FILES.communities);
  const idx = data.findIndex(d => String(d.id) === String(id));
  if (idx === -1) return res.status(404).json({ error: 'Not found' });
  data[idx].members = Array.isArray(data[idx].members) ? data[idx].members : [];
  if (!data[idx].members.includes(user_id)) data[idx].members.push(user_id);
  data[idx].updated_at = new Date().toISOString();
  await writeJSON(DATA_FILES.communities, data);
  res.json({ id: data[idx].id, members: data[idx].members });
});

// Remove community member
app.delete('/api/communities/:id/members/:userId', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  const userId = req.params.userId;
  const data = await readJSON(DATA_FILES.communities);
  const idx = data.findIndex(d => String(d.id) === String(id));
  if (idx === -1) return res.status(404).json({ error: 'Not found' });
  data[idx].members = Array.isArray(data[idx].members) ? data[idx].members.filter(m => String(m) !== String(userId)) : [];
  data[idx].updated_at = new Date().toISOString();
  await writeJSON(DATA_FILES.communities, data);
  res.json({ id: data[idx].id, members: data[idx].members });
});

// Simple site-wide stats
app.get('/api/stats', async (req, res) => {
  await ensureDataFiles();
  const [users, channels, communities, messages] = await Promise.all([
    readJSON(DATA_FILES.users),
    readJSON(DATA_FILES.channels),
    readJSON(DATA_FILES.communities),
    readJSON(DATA_FILES.messages)
  ]);
  res.json({ users: users.length, channels: channels.length, communities: communities.length, messages: messages.length });
});

// ----------------------------
// New non-destructive endpoints
// ----------------------------

// Channels stats: dynamic message_count and member_count for all channels
app.get('/api/channels/stats', async (req, res) => {
  await ensureDataFiles();
  const serverId = req.query.server_id;
  const channels = await readJSON(DATA_FILES.channels);
  const filtered = serverId ? channels.filter(c => String(c.server_id) === String(serverId)) : channels;

  const results = await Promise.all(filtered.map(async (ch) => {
    let chMsgs = await readChannelMessagesFile(ch.id);
    if (!chMsgs || chMsgs.length === 0) {
      const allMsgs = await readJSON(DATA_FILES.messages);
      chMsgs = allMsgs.filter(m => String(m.channel_id) === String(ch.id));
    }
    const message_count = chMsgs.length;
    const unique_users = new Set(chMsgs.filter(m => m.user_id).map(m => String(m.user_id)));
    // include subchannels counts if present
    let subchannel_count = 0;
    if (Array.isArray(ch.subchannels)) subchannel_count = ch.subchannels.length;
    return { ...ch, message_count, member_count: unique_users.size, subchannel_count };
  }));

  results.sort((a,b) => (b.member_count - a.member_count) || (b.message_count - a.message_count));
  res.json(results);
});

// Account tiers (Tingkatan Akun)
app.get('/api/account-tiers', async (req, res) => {
  await ensureDataFiles();
  const tiers = await readJSON(DATA_FILES.account_tiers);
  res.json(tiers);
});

app.post('/api/account-tiers', async (req, res) => {
  await ensureDataFiles();
  const payload = req.body;
  if (!payload || !payload.name) return res.status(400).json({ error: 'name required' });
  const tiers = await readJSON(DATA_FILES.account_tiers);
  const newTier = { id: uuidv4(), ...payload, created_at: new Date().toISOString() };
  tiers.push(newTier);
  await writeJSON(DATA_FILES.account_tiers, tiers);
  res.status(201).json(newTier);
});

app.put('/api/account-tiers/:id', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id; const payload = req.body;
  const tiers = await readJSON(DATA_FILES.account_tiers);
  const idx = tiers.findIndex(t => String(t.id) === String(id));
  if (idx === -1) return res.status(404).json({ error: 'Not found' });
  tiers[idx] = { ...tiers[idx], ...payload, updated_at: new Date().toISOString() };
  await writeJSON(DATA_FILES.account_tiers, tiers);
  res.json(tiers[idx]);
});

app.delete('/api/account-tiers/:id', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  let tiers = await readJSON(DATA_FILES.account_tiers);
  const idx = tiers.findIndex(t => String(t.id) === String(id));
  if (idx === -1) return res.status(404).json({ error: 'Not found' });
  const removed = tiers.splice(idx,1)[0];
  await writeJSON(DATA_FILES.account_tiers, tiers);
  res.json({ deleted: removed });
});

// Bots management and botHelper features
app.get('/api/bots', async (req, res) => {
  await ensureDataFiles();
  const bots = await readJSON(DATA_FILES.bots);
  res.json(bots);
});

// Create a bot user and bot record. Payload: { username, display_name, description }
app.post('/api/bots', async (req, res) => {
  await ensureDataFiles();
  const { username, display_name, description } = req.body || {};
  if (!username) return res.status(400).json({ error: 'username required' });
  const users = await readJSON(DATA_FILES.users);
  if (users.find(u => (u.username || '').toLowerCase() === String(username).toLowerCase())) return res.status(409).json({ error: 'Username already taken' });

  const botId = uuidv4();
  // create minimal user record marked as bot
  const botUser = {
    id: botId,
    username,
    display_name: display_name || username,
    role: 'bot',
    created_at: new Date().toISOString()
  };
  users.push(botUser);
  await writeJSON(DATA_FILES.users, users);

  // create per-user profile file
  const profile = { id: botId, username, display_name: botUser.display_name, role: 'bot', created_at: botUser.created_at, description };
  const userFile = path.join(USERS_DIR, `${botId}.json`);
  await fs.writeFile(userFile, JSON.stringify(profile, null, 2), 'utf8');

  // record bot metadata
  const bots = await readJSON(DATA_FILES.bots);
  const botRecord = { id: botId, user_id: botId, username, display_name: botUser.display_name, description, created_at: botUser.created_at };
  bots.push(botRecord);
  await writeJSON(DATA_FILES.bots, bots);

  res.status(201).json(botRecord);
});

// Delete a bot (removes bot record and user record, and user profile file)
app.delete('/api/bots/:id', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id;
  let bots = await readJSON(DATA_FILES.bots);
  const bidx = bots.findIndex(b => String(b.id) === String(id) || String(b.user_id) === String(id));
  if (bidx === -1) return res.status(404).json({ error: 'Bot not found' });
  const removedBot = bots.splice(bidx, 1)[0];
  await writeJSON(DATA_FILES.bots, bots);

  // remove from users central list
  const users = await readJSON(DATA_FILES.users);
  const uidx = users.findIndex(u => String(u.id) === String(removedBot.user_id) || String(u.id) === String(removedBot.id));
  if (uidx !== -1) {
    users.splice(uidx,1);
    await writeJSON(DATA_FILES.users, users);
  }
  // remove per-user file if present
  try { const uf = path.join(USERS_DIR, `${removedBot.user_id}.json`); if (existsSync(uf)) await fs.unlink(uf); } catch (err) {}

  res.json({ deleted: removedBot });
});

// Bot send message: POST /api/bots/:id/send { channel_id, content }
app.post('/api/bots/:id/send', async (req, res) => {
  await ensureDataFiles();
  const botId = req.params.id;
  const { channel_id, content } = req.body || {};
  if (!channel_id || !content) return res.status(400).json({ error: 'channel_id and content required' });
  const bots = await readJSON(DATA_FILES.bots);
  const bot = bots.find(b => String(b.id) === String(botId) || String(b.user_id) === String(botId));
  if (!bot) return res.status(404).json({ error: 'Bot not found' });

  // create message as bot
  const messages = await readJSON(DATA_FILES.messages);
  const newMessage = { id: uuidv4(), channel_id: channel_id, user_id: bot.user_id || bot.id, content, created_at: new Date().toISOString(), bot: true };
  messages.push(newMessage);
  await writeJSON(DATA_FILES.messages, messages);
  try {
    const chMsgs = await readChannelMessagesFile(channel_id);
    chMsgs.push(newMessage);
    await writeChannelMessagesFile(channel_id, chMsgs);
  } catch (err) {
    // non-fatal
  }
  // attach profile
  const profile = await getProfileForUser(newMessage.user_id);
  const outgoing = { ...newMessage, profiles: profile };
  io.to(String(channel_id)).emit('message', outgoing);
  res.status(201).json(outgoing);
});

// Subchannel management: store subchannels as nested array on parent channel
app.post('/api/channels/:id/subchannels', async (req, res) => {
  await ensureDataFiles();
  const parentId = req.params.id;
  const { name, position } = req.body || {};
  if (!name) return res.status(400).json({ error: 'name required' });
  const channels = await readJSON(DATA_FILES.channels);
  const idx = channels.findIndex(c => String(c.id) === String(parentId));
  if (idx === -1) return res.status(404).json({ error: 'Parent channel not found' });
  const sub = { id: uuidv4(), name, position: typeof position === 'number' ? position : (channels[idx].subchannels ? channels[idx].subchannels.length : 0), created_at: new Date().toISOString() };
  channels[idx].subchannels = Array.isArray(channels[idx].subchannels) ? channels[idx].subchannels : [];
  channels[idx].subchannels.push(sub);
  channels[idx].updated_at = new Date().toISOString();
  await writeJSON(DATA_FILES.channels, channels);
  res.status(201).json(sub);
});

app.delete('/api/channels/:id/subchannels/:subId', async (req, res) => {
  await ensureDataFiles();
  const parentId = req.params.id; const subId = req.params.subId;
  const channels = await readJSON(DATA_FILES.channels);
  const idx = channels.findIndex(c => String(c.id) === String(parentId));
  if (idx === -1) return res.status(404).json({ error: 'Parent channel not found' });
  channels[idx].subchannels = Array.isArray(channels[idx].subchannels) ? channels[idx].subchannels.filter(s => String(s.id) !== String(subId)) : [];
  channels[idx].updated_at = new Date().toISOString();
  await writeJSON(DATA_FILES.channels, channels);
  res.json({ id: parentId, subchannels: channels[idx].subchannels });
});

app.post('/api/channels/:id/subchannels/:subId/rename', async (req, res) => {
  await ensureDataFiles();
  const parentId = req.params.id; const subId = req.params.subId; const { name } = req.body || {};
  if (!name) return res.status(400).json({ error: 'name required' });
  const channels = await readJSON(DATA_FILES.channels);
  const idx = channels.findIndex(c => String(c.id) === String(parentId));
  if (idx === -1) return res.status(404).json({ error: 'Parent channel not found' });
  channels[idx].subchannels = Array.isArray(channels[idx].subchannels) ? channels[idx].subchannels : [];
  const sidx = channels[idx].subchannels.findIndex(s => String(s.id) === String(subId));
  if (sidx === -1) return res.status(404).json({ error: 'Subchannel not found' });
  channels[idx].subchannels[sidx].name = name;
  channels[idx].subchannels[sidx].updated_at = new Date().toISOString();
  channels[idx].updated_at = new Date().toISOString();
  await writeJSON(DATA_FILES.channels, channels);
  res.json(channels[idx].subchannels[sidx]);
});


function _sampleCommunity(i) {
  return { id: uuidv4(), kind: 'community_extra', index: i, title: `Auto community item ${i}`, description: `Generated item ${i}`, created_at: new Date().toISOString() };
}

function _sampleStreaming(i) {
  return { id: uuidv4(), kind: 'streaming_extra', index: i, title: `Auto streaming item ${i}`, description: `Generated stream item ${i}`, created_at: new Date().toISOString() };
}

for (let i = 1; i <= 50; i++) {
  const route = `/api/community/extra/${i}`;
  if (i % 2 === 1) {
    // POST -> create an entry (body optional)
    app.post(route, async (req, res) => {
      await ensureDataFiles();
      try {
        const coll = await readJSON(DATA_FILES.expanded_community);
        const payload = (req.body && Object.keys(req.body).length) ? req.body : _sampleCommunity(i);
        const item = { id: uuidv4(), ...payload, auto_index: i, created_at: new Date().toISOString() };
        coll.push(item);
        await writeJSON(DATA_FILES.expanded_community, coll);
        return res.status(201).json(item);
      } catch (err) {
        return res.status(500).json({ error: 'failed to create community item' });
      }
    });
  } else {
    // GET -> list/filter
    app.get(route, async (req, res) => {
      await ensureDataFiles();
      try {
        const coll = await readJSON(DATA_FILES.expanded_community);
        const q = String(req.query.q || '').toLowerCase().trim();
        const out = q ? coll.filter(x => JSON.stringify(x).toLowerCase().includes(q)) : coll;
        return res.json(out);
      } catch (err) {
        return res.status(500).json({ error: 'failed to read community items' });
      }
    });
  }
}

for (let i = 1; i <= 50; i++) {
  const route = `/api/streaming/extra/${i}`;
  if (i % 2 === 1) {
    // POST -> create an entry (body optional)
    app.post(route, async (req, res) => {
      await ensureDataFiles();
      try {
        const coll = await readJSON(DATA_FILES.expanded_streaming);
        const payload = (req.body && Object.keys(req.body).length) ? req.body : _sampleStreaming(i);
        const item = { id: uuidv4(), ...payload, auto_index: i, created_at: new Date().toISOString() };
        coll.push(item);
        await writeJSON(DATA_FILES.expanded_streaming, coll);
        return res.status(201).json(item);
      } catch (err) {
        return res.status(500).json({ error: 'failed to create streaming item' });
      }
    });
  } else {
    // GET -> list/filter
    app.get(route, async (req, res) => {
      await ensureDataFiles();
      try {
        const coll = await readJSON(DATA_FILES.expanded_streaming);
        const q = String(req.query.q || '').toLowerCase().trim();
        const out = q ? coll.filter(x => JSON.stringify(x).toLowerCase().includes(q)) : coll;
        return res.json(out);
      } catch (err) {
        return res.status(500).json({ error: 'failed to read streaming items' });
      }
    });
  }
}


// Ensure data files exist then start server
ensureDataFiles().then(() => {
  server.listen(PORT, () => {
    console.log(`Backend JSON server listening on port ${PORT}`);
  });
}).catch(err => {
  console.error('Failed to prepare data files:', err);
});

// ----------------------------
// Discord & YouTube API surface
// ----------------------------

// ------- Discord endpoints -------
// List discord servers (fall back to deriving servers from channels)
app.get('/api/discord/servers', async (req, res) => {
  await ensureDataFiles();
  let servers = await readJSON(DATA_FILES.discord_servers);
  if (!servers || servers.length === 0) {
    const channels = await readJSON(DATA_FILES.channels);
    const map = new Map();
    channels.forEach(c => {
      if (!map.has(c.server_id)) map.set(c.server_id, { id: c.server_id, name: c.server_name || `Server ${c.server_id}` });
    });
    servers = Array.from(map.values());
  }
  res.json(servers);
});

// Create discord server
app.post('/api/discord/servers', async (req, res) => {
  await ensureDataFiles();
  const payload = req.body || {};
  if (!payload.name) return res.status(400).json({ error: 'name required' });
  const coll = await readJSON(DATA_FILES.discord_servers);
  const item = { id: uuidv4(), name: payload.name, meta: payload.meta || {}, created_at: new Date().toISOString() };
  coll.push(item);
  await writeJSON(DATA_FILES.discord_servers, coll);
  res.status(201).json(item);
});

// Get server
app.get('/api/discord/servers/:id', async (req, res) => {
  await ensureDataFiles();
  const coll = await readJSON(DATA_FILES.discord_servers);
  const item = coll.find(x => String(x.id) === String(req.params.id));
  if (!item) return res.status(404).json({ error: 'Server not found' });
  res.json(item);
});

// Create invite for a server
app.post('/api/discord/servers/:id/invite', async (req, res) => {
  await ensureDataFiles();
  const serverId = req.params.id; const payload = req.body || {};
  const invites = await readJSON(DATA_FILES.discord_invites);
  const invite = { id: uuidv4(), server_id: serverId, code: uuidv4().split('-')[0], max_uses: payload.max_uses || 0, created_at: new Date().toISOString(), expires_at: payload.expires_at || null };
  invites.push(invite);
  await writeJSON(DATA_FILES.discord_invites, invites);
  res.status(201).json(invite);
});

// List invites for a server
app.get('/api/discord/servers/:id/invites', async (req, res) => {
  await ensureDataFiles();
  const serverId = req.params.id;
  const invites = await readJSON(DATA_FILES.discord_invites);
  res.json((invites || []).filter(i => String(i.server_id) === String(serverId)));
});

// Roles: create and list
app.post('/api/discord/roles', async (req, res) => {
  await ensureDataFiles();
  const payload = req.body || {};
  if (!payload.server_id || !payload.name) return res.status(400).json({ error: 'server_id and name required' });
  const roles = await readJSON(DATA_FILES.discord_roles);
  const role = { id: uuidv4(), server_id: payload.server_id, name: payload.name, permissions: payload.permissions || [], created_at: new Date().toISOString() };
  roles.push(role);
  await writeJSON(DATA_FILES.discord_roles, roles);
  res.status(201).json(role);
});

app.get('/api/discord/roles', async (req, res) => {
  await ensureDataFiles();
  const serverId = req.query.server_id;
  let roles = await readJSON(DATA_FILES.discord_roles);
  if (serverId) roles = roles.filter(r => String(r.server_id) === String(serverId));
  res.json(roles);
});

// Webhooks: create, list, send
app.post('/api/discord/webhooks', async (req, res) => {
  await ensureDataFiles();
  const payload = req.body || {};
  if (!payload.server_id || !payload.channel_id || !payload.url) return res.status(400).json({ error: 'server_id, channel_id and url required' });
  const hooks = await readJSON(DATA_FILES.discord_webhooks);
  const h = { id: uuidv4(), server_id: payload.server_id, channel_id: payload.channel_id, url: payload.url, name: payload.name || 'webhook', created_at: new Date().toISOString() };
  hooks.push(h);
  await writeJSON(DATA_FILES.discord_webhooks, hooks);
  res.status(201).json(h);
});

app.get('/api/discord/webhooks', async (req, res) => {
  await ensureDataFiles();
  const serverId = req.query.server_id;
  let hooks = await readJSON(DATA_FILES.discord_webhooks);
  if (serverId) hooks = hooks.filter(h => String(h.server_id) === String(serverId));
  res.json(hooks);
});

// Simulate sending via webhook: will create message in channel and emit via sockets
app.post('/api/discord/webhooks/:id/send', async (req, res) => {
  await ensureDataFiles();
  const id = req.params.id; const payload = req.body || {};
  const hooks = await readJSON(DATA_FILES.discord_webhooks);
  const hook = hooks.find(h => String(h.id) === String(id));
  if (!hook) return res.status(404).json({ error: 'Webhook not found' });
  const content = payload.content || payload.message || 'Webhook message';
  const messages = await readJSON(DATA_FILES.messages);
  const newMessage = { id: uuidv4(), channel_id: hook.channel_id, user_id: null, content, created_at: new Date().toISOString(), webhook_id: hook.id };
  messages.push(newMessage);
  await writeJSON(DATA_FILES.messages, messages);
  try { const chMsgs = await readChannelMessagesFile(hook.channel_id); chMsgs.push(newMessage); await writeChannelMessagesFile(hook.channel_id, chMsgs); } catch (err) {}
  io.to(String(hook.channel_id)).emit('message', newMessage);
  res.status(201).json(newMessage);
});

// Presence: get/set simple presence state
app.get('/api/discord/presence/:userId', async (req, res) => {
  await ensureDataFiles();
  const presence = await readJSON(DATA_FILES.discord_presence);
  const p = (presence || []).find(x => String(x.user_id) === String(req.params.userId));
  res.json(p || { user_id: req.params.userId, status: 'offline' });
});

app.post('/api/discord/presence/:userId', async (req, res) => {
  await ensureDataFiles();
  const uid = req.params.userId; const payload = req.body || {};
  const presence = await readJSON(DATA_FILES.discord_presence);
  const idx = presence.findIndex(x => String(x.user_id) === String(uid));
  const entry = { user_id: uid, status: payload.status || 'online', activities: payload.activities || [], updated_at: new Date().toISOString() };
  if (idx === -1) presence.push(entry); else presence[idx] = { ...presence[idx], ...entry };
  await writeJSON(DATA_FILES.discord_presence, presence);
  res.json(entry);
});

// ------- YouTube endpoints -------
// Channels list/create/get
app.get('/api/youtube/channels', async (req, res) => {
  await ensureDataFiles();
  const q = String(req.query.q || '').toLowerCase().trim();
  let coll = await readJSON(DATA_FILES.youtube_channels);
  if (q) coll = coll.filter(c => (c.title || '').toLowerCase().includes(q) || (c.description || '').toLowerCase().includes(q));
  res.json(coll);
});

app.post('/api/youtube/channels', async (req, res) => {
  await ensureDataFiles();
  const payload = req.body || {};
  if (!payload.title) return res.status(400).json({ error: 'title required' });
  const coll = await readJSON(DATA_FILES.youtube_channels);
  const item = { id: uuidv4(), title: payload.title, description: payload.description || '', created_at: new Date().toISOString() };
  coll.push(item);
  await writeJSON(DATA_FILES.youtube_channels, coll);
  res.status(201).json(item);
});

app.get('/api/youtube/channels/:id', async (req, res) => {
  await ensureDataFiles();
  const coll = await readJSON(DATA_FILES.youtube_channels);
  const item = coll.find(c => String(c.id) === String(req.params.id));
  if (!item) return res.status(404).json({ error: 'Channel not found' });
  res.json(item);
});

// Videos: create, list by channel, get
app.get('/api/youtube/channels/:id/videos', async (req, res) => {
  await ensureDataFiles();
  const vids = await readJSON(DATA_FILES.youtube_videos);
  res.json((vids || []).filter(v => String(v.channel_id) === String(req.params.id)));
});

app.post('/api/youtube/videos', async (req, res) => {
  await ensureDataFiles();
  const p = req.body || {};
  if (!p.title || !p.channel_id) return res.status(400).json({ error: 'title and channel_id required' });
  const coll = await readJSON(DATA_FILES.youtube_videos);
  const item = { id: uuidv4(), channel_id: p.channel_id, title: p.title, description: p.description || '', views: p.views || 0, likes: p.likes || 0, created_at: new Date().toISOString() };
  coll.push(item);
  await writeJSON(DATA_FILES.youtube_videos, coll);
  res.status(201).json(item);
});

app.get('/api/youtube/videos/:id', async (req, res) => {
  await ensureDataFiles();
  const vids = await readJSON(DATA_FILES.youtube_videos);
  const v = vids.find(x => String(x.id) === String(req.params.id));
  if (!v) return res.status(404).json({ error: 'Video not found' });
  res.json(v);
});

// Video comments: post and list
app.post('/api/youtube/videos/:id/comments', async (req, res) => {
  await ensureDataFiles();
  const vid = req.params.id; const p = req.body || {};
  if (!p.author || !p.message) return res.status(400).json({ error: 'author and message required' });
  const coll = await readJSON(DATA_FILES.youtube_comments);
  const c = { id: uuidv4(), video_id: vid, author: p.author, message: p.message, created_at: new Date().toISOString() };
  coll.push(c);
  await writeJSON(DATA_FILES.youtube_comments, coll);
  res.status(201).json(c);
});

app.get('/api/youtube/videos/:id/comments', async (req, res) => {
  await ensureDataFiles();
  const vid = req.params.id;
  const coll = await readJSON(DATA_FILES.youtube_comments);
  res.json((coll || []).filter(x => String(x.video_id) === String(vid)).slice(-200));
});

// Live streams
app.get('/api/youtube/live', async (req, res) => {
  await ensureDataFiles();
  const coll = await readJSON(DATA_FILES.youtube_live_streams);
  res.json(coll || []);
});

// Simple analytics aggregation for a channel
app.get('/api/youtube/analytics/channel/:id', async (req, res) => {
  await ensureDataFiles();
  const channelId = req.params.id;
  const vids = (await readJSON(DATA_FILES.youtube_videos)).filter(v => String(v.channel_id) === String(channelId));
  const analytics = await readJSON(DATA_FILES.youtube_analytics);
  // compute totals from videos data and analytics store
  const total_views = vids.reduce((s, v) => s + (v.views || 0), 0);
  const total_likes = vids.reduce((s, v) => s + (v.likes || 0), 0);
  const extra = analytics.find(a => String(a.channel_id) === String(channelId)) || {};
  res.json({ channel_id: channelId, total_videos: vids.length, total_views, total_likes, extra });
});

